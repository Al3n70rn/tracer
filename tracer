#!/usr/bin/env python

import pdb

############################################################################## 
# TraCeR - a tool to reconstruct TCR sequences from single-cell RNA-seq data #
#                      EDIT tracer.conf BEFORE USE!                          #       
#                                                                            #
# Please see README and LICENCE for details of use and licence conditions.   #
# This software was written by Mike Stubbington (mstubb@ebi.ac.uk) from the  #
# Teichmann Lab, EMBL-EBI (www.teichlab.org). Latest versions are available  #
# for download at www.github.com/teichlab/tracer.                            #
#                                                                            #
#      Copyright (c) 2015 EMBL - European Bioinformatics Institute           # 
############################################################################## 

import tracer_func as tracer
import ConfigParser
import argparse
import sys
import os
import subprocess
import pipes
import glob
import shutil
import re
from collections import defaultdict, Counter
from time import sleep
import warnings

class Launcher():
    def __init__(self):
        parser = argparse.ArgumentParser(description='TraCeR: reconstruction of TCR sequences from single-cell RNAseq data', usage = ''' tracer <mode> [<args>]
        
        Modes are :
        
        - assemble: assemble TCR sequences from single-cell RNA-sequencing reads
        - network: summarise TCR sequences from set of cells, build clonotype networks
        - build_synth_genome: build synthetic genomes and Bowtie2 indices for read extraction
        - build_igblast_index: build index for use with IgBlast
        
        use tracer <mode> -h for specific help
        ''')
        parser.add_argument('mode', metavar="<MODE>", help='tracer mode (assemble, build or network)', choices = ['assemble', 'build_synth_genome', 'network', 'build_igblast_index'])
        args = parser.parse_args(sys.argv[1:2])
        
        if not hasattr(self, args.mode):
            print 'Unrecognised mode'
            parser.print_help()
            exit(1)
        
        
        
        
        getattr(self, args.mode)()
        
        
        
        
        
        
        

    def assemble(self):
        parser = argparse.ArgumentParser(description = "Reconstruct TCR sequences from RNAseq reads for a single cell")
        parser.add_argument('--ncores', '-p', metavar="<CORES>", help='number of processor cores to use')
        parser.add_argument('--config_file', '-c', metavar="<CONFIG_FILE>", help='config file to use [tracer.conf]', default='tracer.conf')
        parser.add_argument('--resume_with_existing_files', '-r', help='look for existing intermediate files and use those instead of starting from scratch', action="store_true")
        parser.add_argument('fastq1', metavar="<FASTQ1>", help='first fastq file')
        parser.add_argument('fastq2', metavar="<FASTQ2>", help='second fastq file')
        parser.add_argument('cell_name', metavar="<CELL_NAME>", help='name of cell for file labels')
        parser.add_argument('expt_label', metavar="<EXPERIMENT_LABEL>", help='label for experiment to which cell belongs')
        parser.add_argument('output_dir', metavar="<OUTPUT_DIR>", help='directory for output as <output_dir>/<cell_name>')
        args = parser.parse_args(sys.argv[2:])
        
        cell_name = args.cell_name
        fastq1 = args.fastq1
        fastq2 = args.fastq2
        ncores = args.ncores
        expt_label = args.expt_label
        
        #Read config file
        config = ConfigParser.ConfigParser()
        config.read(args.config_file)
        
        bowtie2 = config.get('tool_locations', 'bowtie2_path')
        igblast = config.get('tool_locations', 'igblast_path')
        kallisto = config.get('tool_locations', 'kallisto_path')
        trinity = config.get('tool_locations', 'trinity_path')
        
        if config.has_option('trinity_options', 'trinity_grid_conf'):
            trinity_grid_conf = config.get('trinity_options', 'trinity_grid_conf')
        else:
            trinity_grid_conf = False
        
        
        
        synthetic_genome_path = config.get('bowtie2_options', 'synthetic_genome_index_path')
        
        igblast_index_name_format = config.get('IgBlast_options', 'igblast_index_name')
        igblast_aux_data = config.get('IgBlast_options', 'igblast_aux_data')
        organism = config.get('IgBlast_options', 'organism')
        igblast_seqtype = config.get('IgBlast_options', 'igblast_seqtype')
        imgt_seq_location = config.get('IgBlast_options', 'imgt_seq_location')
        
        
        kallisto_base_transcriptome = config.get('kallisto_options', 'base_transcriptome')
        
        #check that executables from config file can be used
        not_executable = []
        for name, x in {"bowtie2":bowtie2, "igblast":igblast, "kallisto":kallisto, "trinity":trinity}.iteritems():
            if not tracer.is_exe(x):
                not_executable.append((name, x))
        if len(not_executable) > 0:
            print
            print "Could not execute the following required tools. Check your configuration file."
            for t in not_executable:
                print t[0], t[1]
            print
            exit(1)
            
        
        #set-up output directories
        root_output_dir = os.path.abspath(args.output_dir)
        tracer.makeOutputDir(root_output_dir)
        output_dir = root_output_dir + "/" + cell_name
        
        tracer.makeOutputDir(output_dir)
        
        data_dirs = ['aligned_reads','Trinity_output', 'IgBLAST_output', 'unfiltered_TCR_seqs', 'expression_quantification', 'filtered_TCR_seqs']
        for d in data_dirs:
            tracer.makeOutputDir("{}/{}".format(output_dir, d))
        
        locus_names = ["TCRB", "TCRA"]
        
        should_resume = args.resume_with_existing_files
        
        self.bowtie2_alignment(bowtie2, ncores, locus_names, output_dir, cell_name, synthetic_genome_path, fastq1, fastq2, should_resume)
        print
        trinity_JM = config.get('trinity_options', 'max_jellyfish_memory')
        self.assemble_with_trinity(trinity, locus_names, output_dir, cell_name, ncores, trinity_grid_conf, trinity_JM, should_resume)
        print
        self.run_IgBlast(igblast, locus_names, output_dir, cell_name, igblast_aux_data, igblast_index_name_format, organism, igblast_seqtype, should_resume)
        print
        
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            cell = tracer.parse_IgBLAST(locus_names, output_dir, cell_name, expt_label, imgt_seq_location)

        self.quantify_with_kallisto(kallisto, cell, output_dir, cell_name, kallisto_base_transcriptome, fastq1, fastq2, ncores, should_resume)
        print
        counts = tracer.load_kallisto_counts("{}/expression_quantification/kallisto_output/abundance.tsv".format(output_dir))
        
        for locus, recombinants in cell.all_recombinants.iteritems():
            if recombinants is not None:
                for rec in recombinants:
                    tpm = counts[locus][rec.contig_name]
                    rec.TPM = tpm
        
        self.print_cell_summary(cell, "{output_dir}/unfiltered_TCR_seqs".format(output_dir=output_dir))
        
    def bowtie2_alignment(self, bowtie2, ncores, locus_names, output_dir, cell_name, synthetic_genome_path, fastq1, fastq2, should_resume):
        print "##Finding TCR-derived reads##"
        
        if should_resume:
            for locus in locus_names:
                aligned_read_path = "{}/aligned_reads/{}_{}_".format(output_dir, cell_name, locus)
                fastq1_out= "{}1.fastq".format(aligned_read_path)
                fastq2_out= "{}2.fastq".format(aligned_read_path)
                if os.path.isfile(fastq1_out) and os.path.isfile(fastq2_out):
                    print "Resuming with existing TCRA and B reads"
                    return
        
        for locus in locus_names:
            print "##{}##".format(locus)
            sam_file = "{}/aligned_reads/{}_{}.sam".format(output_dir, cell_name, locus)
            aligned_read_path = "{}/aligned_reads/{}_{}_%.fastq".format(output_dir, cell_name, locus)
            command = [bowtie2, '--no-unal', '-p', ncores, '-k', '1', '--np', '0', '--rdg', '1,1', '--rfg', '1,1', '-x', "/".join([synthetic_genome_path, locus]), '-1', fastq1, '-2', fastq2, '--al-conc', aligned_read_path, '-S', sam_file]
            

            subprocess.check_call(command)
        
            
    
    
    
    
    def assemble_with_trinity(self, trinity, locus_names, output_dir, cell_name, ncores, trinity_grid_conf, JM, should_resume):
        print  "##Assembling Trinity Contigs##"
        
        if should_resume:
            trinity_report_successful =  "{}/Trinity_output/successful_trinity_assemblies.txt".format(output_dir)
            trinity_report_unsuccessful = "{}/Trinity_output/unsuccessful_trinity_assemblies.txt".format(output_dir)
            if os.path.isfile(trinity_report_successful) and os.path.isfile(trinity_report_unsuccessful):
                print "Resuming with existing Trinity output"
                return
        
        
        command = [trinity]
        if trinity_grid_conf:
            command = command + ['--grid_conf', trinity_grid_conf]
        
        command = command + ['--JM', JM, '--seqType', 'fq', '--CPU', ncores, '--full_cleanup']
        
        for locus in locus_names:
            print "##{}##".format(locus)
            trinity_output = "{}/Trinity_output/{}_{}".format(output_dir, cell_name, locus)
            aligned_read_path = "{}/aligned_reads/{}_{}_".format(output_dir, cell_name, locus)
            file1 = "{}1.fastq".format(aligned_read_path)
            file2 = "{}2.fastq".format(aligned_read_path)
            command = command + ["--left", file1, "--right", file2, "--output", '{}'.format(trinity_output)]
            subprocess.check_call(command)
        
        #clean up unsuccessful assemblies
        sleep(10) #this gives the cluster filesystem time to catch up and stops weird things happening
        successful_files = glob.glob("{}/Trinity_output/*.fasta".format(output_dir))
        unsuccessful_directories = os.walk("{}/Trinity_output".format(output_dir)).next()[1]
        for directory in unsuccessful_directories:
            shutil.rmtree(directory)
        successful_file_summary = "{}/Trinity_output/successful_trinity_assemblies.txt".format(output_dir)
        unsuccessful_file_summary = "{}/Trinity_output/unsuccessful_trinity_assemblies.txt".format(output_dir)
    
        successful_files = tracer.clean_file_list(successful_files)
        unsuccessful_directories = tracer.clean_file_list(unsuccessful_directories)
    
    
        success_out = open(successful_file_summary, "w")
        fail_out = open(unsuccessful_file_summary, "w")
    
        successful = defaultdict(list)
        unsuccessful = defaultdict(list)
    
        successful_ordered_files = set()
        unsuccessful_ordered_files = set()
    
        for filename in successful_files:
            #success_out.write("{}\n".format(filename))
            parsed_name = tracer.get_filename_and_locus(filename)
            successful[parsed_name[0]].append(parsed_name[1])
            successful_ordered_files.add(parsed_name[0])
        successful_ordered_files = sorted(list(successful_ordered_files))
        
    
        for filename in unsuccessful_directories:
            #fail_out.write("{}\n".format(filename))
            parsed_name = tracer.get_filename_and_locus(filename)
            unsuccessful[parsed_name[0]].append(parsed_name[1])
            unsuccessful_ordered_files.add(parsed_name[0])
        unsuccessful_ordered_files = sorted(list(unsuccessful_ordered_files))
        
        successful = tracer.sort_locus_names(successful)
        unsuccessful = tracer.sort_locus_names(unsuccessful)
    
        for file in successful_ordered_files:
            success_out.write("{}\t{}\n".format(file, successful[file]))
    
        for file in unsuccessful_ordered_files:
            fail_out.write("{}\t{}\n".format(file, unsuccessful[file]))
    
        success_out.close()
        fail_out.close()
        
        if len(unsuccessful_directories) == 2:
            print "No successful Trinity assemblies"
            exit(1)
    
    
    def run_IgBlast(self, igblast, locus_names, output_dir, cell_name, auxdatafile, index_name_format, organism, ig_seqtype, should_resume):
        print  "##Running IgBLAST##"
        
        if should_resume:
            igblast_out_A = "{output_dir}/IgBLAST_output/{cell_name}_TCRA.IgBLASTOut".format(output_dir=output_dir, cell_name=cell_name)
            igblast_out_B = "{output_dir}/IgBLAST_output/{cell_name}_TCRB.IgBLASTOut".format(output_dir=output_dir, cell_name=cell_name)
            if os.path.isfile(igblast_out_A) or os.path.isfile(igblast_out_B):
                print "Resuming with existing IgBLAST output"
                return
        
        databases = {}
        for segment in ['v','d','j']:
            databases[segment] = index_name_format.replace("$segment", segment)
             
        for locus in locus_names:
            print "##{}##".format(locus)
            trinity_fasta = "{}/Trinity_output/{}_{}.Trinity.fasta".format(output_dir, cell_name, locus)
            command = [igblast, '-germline_db_V', databases['v'], '-germline_db_D', databases['d'], '-germline_db_J', databases['j'], '-organism', organism, '-domain_system', 'imgt', '-ig_seqtype', ig_seqtype, '-auxiliary_data', auxdatafile, '-show_translation', '-num_alignments_V', '5', '-num_alignments_D', '5', '-num_alignments_J', '5', '-outfmt', '7', '-query', trinity_fasta]
            igblast_out = "{output_dir}/IgBLAST_output/{cell_name}_{locus}.IgBLASTOut".format(output_dir=output_dir, cell_name=cell_name, locus=locus)
            out = open(igblast_out, 'w')
            subprocess.check_call(command, stdout=out)
            out.close()
        
    
    
    def quantify_with_kallisto(self, kallisto, cell, output_dir, cell_name, kallisto_base_transcriptome, fastq1, fastq2, ncores, should_resume):
        print "##Running Kallisto##"
        if should_resume:
            if os.path.isfile("{}/expression_quantification/kallisto_output/abundance.tsv".format(output_dir)):
                print "Resuming with existing Kallisto output"
                return
        
        print "##Making Kallisto indices##"
        kallisto_dirs = ['kallisto_index', 'kallisto_output']
        for d in kallisto_dirs:
            tracer.makeOutputDir("{}/expression_quantification/{}".format(output_dir, d))
        fasta_filename = "{output_dir}/unfiltered_TCR_seqs/{cell_name}_TCRseqs.fa".format(output_dir=output_dir, cell_name=cell_name)
        fasta_file = open(fasta_filename, 'w')
        fasta_file.write(cell.get_fasta_string())    
        fasta_file.close()
        
        output_transcriptome = "{}/expression_quantification/kallisto_index/{}_transcriptome.fa".format(output_dir, cell_name)
        with open(output_transcriptome, 'w') as outfile:
            for fname in [kallisto_base_transcriptome, fasta_filename]:
                with open(fname) as infile:
                    for line in infile:
                        outfile.write(line)
        
        idx_file = "{}/expression_quantification/kallisto_index/{}_transcriptome.idx".format(output_dir, cell_name)
        
        index_command = [kallisto, 'index', '-i', idx_file, output_transcriptome]
        subprocess.check_call(index_command)
        print "##Quantifying with Kallisto##"
        kallisto_command = [kallisto, 'quant', '-i', idx_file, '-t', ncores, '-o', "{}/expression_quantification/kallisto_output".format(output_dir), fastq1, fastq2]
        subprocess.check_call(kallisto_command)
        
        #delete index file because it's huge and unecessary
        os.remove(idx_file)
        
        
    def print_cell_summary(self, cell, output_dir):
        out_file = open("{}/unfiltered_TCRs.txt".format(output_dir), 'w')
        out_file.write('------------------\n{name}\n------------------\n'.format(name=cell.name))
        out_file.write('TCRA recombinants: {}\n'.format(cell.summarise_productivity('A')))
        out_file.write('TCRB recombinants: {}\n'.format(cell.summarise_productivity('B')))
        out_file.write('\n\n')
        out_file.write('#TCRA#\n')
        for rec in cell.A_recombinants:
            out_file.write(rec.get_summary())
            out_file.write("\n\n")
        out_file.write('#TCRB#\n')
        for rec in cell.B_recombinants:
            out_file.write(rec.get_summary())
            out_file.write("\n\n")
        out_file.close()
        #add stuff here about numbers of recombinants and then details.


if __name__ == '__main__':
    Launcher()